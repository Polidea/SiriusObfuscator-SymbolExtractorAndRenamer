# Check the handling of discovered dependencies that expose cycles

# We test with a simple command that just writes a fake .d file which lists an
# input dependency on "header-1", which is also generated by the "app-1" rule

# RUN: rm -rf %t.build
# RUN: mkdir -p %t.build
# RUN: touch %t.build/header-1 %t.build/input-1
# RUN: cp %s %t.build/build.llbuild


# Check the first build.
#
# RUN: %{llbuild} buildsystem build --serial --chdir %t.build > %t1.out
# RUN: %{FileCheck} --check-prefix=CHECK-INITIAL --input-file=%t1.out %s
#
# CHECK-INITIAL: CC plugin-1
# CHECK-INITIAL: PACKAGE app-1


# Check a followup build
#
# RUN: %{llbuild} buildsystem build --serial --chdir %t.build &> %t2.out || true
# RUN: %{FileCheck} --check-prefix=CHECK-AFTER --input-file=%t2.out %s
#
# CHECK-AFTER: error: cycle detected while building: target '' -> node 'app-1' -> command 'app-1' -> node 'plugin-1' -> command 'plugin-1' -> node 'header-1' -> command 'app-1'

client:
  name: basic

targets:
  "": ["app-1"]

commands:
  plugin-1:
    tool: shell
    inputs: ["input-1"]
    outputs: ["plugin-1"]
    # See `DependencyInfoParser` for information on the format.
    args: "env printf '\\0VERSION\\0\\020input-1\\00\\020header-1\\00' > plugin-1.d && cat input-1 header-1 > plugin-1"
    description: CC plugin-1
    deps: plugin-1.d
    deps-style: dependency-info

  app-1:
    tool: shell
    inputs: ["plugin-1"]
    outputs: ["header-1", "app-1"]
    args: "touch header-1 && cat plugin-1 > app-1"
    description: PACKAGE app-1

